#======================================================================
#                    L A D C P P R O C . B A C K S C A T T E R 
#                    doc: Wed Oct 20 13:02:27 2010
#                    dlm: Fri Jul 15 11:39:37 2011
#                    (c) 2010 A.M. Thurnherr
#                    uE-Info: 106 65 NIL 0 0 72 2 2 4 NIL ofnI
#======================================================================

# HISTORY:
#	Oct 20, 2010: - created
#	Dec 10, 2010: - BUG: backscatter above sea surface made code bomb
#						 when run with uplooker data
#	Jun 15, 2011: - added calculation of backscatter profiles from
#				    subset of bins
#	Jul  7, 2011: - use $BEAM? vars to clarify code
#				  - save SV values to use in BT code
#	Jul 14, 2011: - implemented Sv_V04
#	Jul 15, 2011: - modified Sv_V04 to take noise levels into account

my($BEAM1) = 0;
my($BEAM2) = 1;
my($BEAM3) = 2;
my($BEAM4) = 3;

#----------------------------------------------------------------------
# Volume Scattering Coefficient, following Deines (IEEE 1999)
# NOTES:
#	- instrument specific! (300kHz Workhorse)
#   - no sound-speed correction applied
#   - R in bin center, instead of last quarter
#   - transmit power assumes 33V batteries
#----------------------------------------------------------------------

# NB:
#	- correction seems to work for a subset of bins (~bins 3-9 for 
#	  2010 P403 station 46) 
#	- this may imply that noise level depends on bin
# 	- far bins are important for seabed detection, i.e. cannot simply
#	  be discarded at this stage

sub log10 {
    my $n = shift;
    return log($n)/log(10);
}   

sub Sv_D99($$$$$)
{
    my($temp,$PL,$Er,$R,$EA) = @_;
    my($C)      = -143;                 # RDI Workhorse monitor
    my($Ldbm)   = 10 * log10($PL);
    my($PdbW)   = 14.0;
    my($alpha)  = 0.069;
    my($Kc)     = 0.45;
    
    return $C + 10*log10(($temp+273)*$R**2) - $Ldbm - $PdbW
              + 2*$alpha*$R + $Kc*($EA-$Er);
}

#----------------------------------------------------------------------
# Volume Scattering Coefficient, following Visbeck (code 2004)
#
## function [ts,bcs]=targ($EA,$R,$alpha,$PL,$EAS,$ap)
## Target strength of EA for volume scatterer
## $EA = echoamp in  dB
## $R = distance in  m
## $alpha = attenuation dB/m
## $PL = pulse/bin legth in  m
## $EAS = source level
## $ap = aperature in degree
## M. Visbeck 2004

# NB:
#	- overall, correction with distance works similarly well to Deines (1999)
#	- constant bias, which could be taken care of by changing EAS
#	- however, much more serious UL/DL differences

sub Sv_V04($$$$$)
{
    my($temp,$PL,$Er,$R,$EA) = @_;	# only uses $R and $EA

#	my($alpha) = 0.039;		## attenuation dB/m for 150 kHz
	my($alpha) = 0.062;		## attenuation dB/m for 300 kHz
	my($EAS) = 100;			## source level in dB
	my($ap) = rad(2);		## beam aperature in DEGREE convert to radian

	my($r1) = tan($ap)*($R-$PL/2);	## radius of top and bottom of each bin
	my($r2) = tan($ap)*($R+$PL/2);
	my($V) = $PI*$PL/3 * ($r1**2+$r2**2+$r1*$r2);	## ensonified volume 

	my($TL) = 20*log10($R) + $alpha*$R;				## transmission loss

	my($TS) = 0.45*$EA - $EAS + 2*$TL - 10*log10($V);	## target strength
	my($BCS) = exp($TS/10);							## backscatter cross section

	return $TS;
}


# modifications from Visbeck:
#	- add 0.05 to beam radius
#	- take beam noise into account
#	- corrected(?) ensonified volume

# NB:
#	- beam noise takes care of UL/DL differences
#	- constant bias, which could be taken care of by changing EAS
#	- remaining changes don't do much

sub Sv_T11($$$$$)
{
    my($temp,$PL,$Er,$R,$EA) = @_;

	my($alpha) = 0.062;		## attenuation dB/m for 300 kHz
	my($EAS) = 100;			## source level in dB
	my($ap) = rad(2);		## beam aperature in DEGREE convert to radian

	my($r1) = 0.05 + tan($ap)*($R-$PL/2);	## radius of top and bottom of each bin
	my($r2) = 0.05 + tan($ap)*($R+$PL/2);
	my($V) = $PI*($r1**2+$r2**2)/2 * $PL;	## ensonified volume 

	my($TL) = 20*log10($R) + $alpha*$R;		## transmission loss

	my($TS) = 0.45*($EA-$Er) - $EAS + 2*$TL - 10*log10($V);	## target strength

	return $TS;
}

sub mk_backscatter_profs($$)
{
	my($LADCP_start,$LADCP_end) = @_;
	
	my(@Er) = (1e99,1e99,1e99,1e99);						# echo intensity reference level
	for (my($ens)=$LADCP_start; $ens<=$LADCP_end; $ens++) {
		$Er[$BEAM1] = $LADCP{ENSEMBLE}[$ens]->{ECHO_AMPLITUDE}[$LADCP{N_BINS}-1][$BEAM1]
			if ($LADCP{ENSEMBLE}[$ens]->{ECHO_AMPLITUDE}[$LADCP{N_BINS}-1][$BEAM1] < $Er[$BEAM1]);
		$Er[$BEAM2] = $LADCP{ENSEMBLE}[$ens]->{ECHO_AMPLITUDE}[$LADCP{N_BINS}-1][$BEAM2]
			if ($LADCP{ENSEMBLE}[$ens]->{ECHO_AMPLITUDE}[$LADCP{N_BINS}-1][$BEAM2] < $Er[$BEAM2]);
		$Er[$BEAM3] = $LADCP{ENSEMBLE}[$ens]->{ECHO_AMPLITUDE}[$LADCP{N_BINS}-1][$BEAM3]
			if ($LADCP{ENSEMBLE}[$ens]->{ECHO_AMPLITUDE}[$LADCP{N_BINS}-1][$BEAM3] < $Er[$BEAM3]);
		$Er[$BEAM4] = $LADCP{ENSEMBLE}[$ens]->{ECHO_AMPLITUDE}[$LADCP{N_BINS}-1][$BEAM4]
			if ($LADCP{ENSEMBLE}[$ens]->{ECHO_AMPLITUDE}[$LADCP{N_BINS}-1][$BEAM4] < $Er[$BEAM4]);
    }
	print(STDERR "\n\t\@per-beam noise levels = @Er") if ($opt_d);

	for (my($ens)=$LADCP_start; $ens<=$LADCP_end; $ens++) {
		for (my($bin)=0; $bin<$LADCP{N_BINS}; $bin++) {
			my($gi) = int(&depthOfBin($ens,$bin) / $GRID_DZ);
			next if ($gi < 0);
			my($range_to_bin) = &dzToBin($ens,$bin) / cos(rad($LADCP{BEAM_ANGLE}));

			my($Svfunc);
			if ($opt_u =~ /^[dD]/) {
				$Svfunc = \&Sv_D99;
			} elsif ($opt_u =~ /^[vV]/) {
				$Svfunc = \&Sv_V04;
			} else {
				$Svfunc = \&Sv_T11;
			}

			$LADCP{ENSEMBLE}[$ens]->{SV}[$bin][$BEAM1] = &$Svfunc($LADCP{ENSEMBLE}[$ens]->{CTD_TEMP},
							 							    $LADCP{TRANSMITTED_PULSE_LENGTH},
														    $Er[$BEAM1],$range_to_bin,
							            			        $LADCP{ENSEMBLE}[$ens]->{ECHO_AMPLITUDE}[$bin][$BEAM1]);
			$LADCP{ENSEMBLE}[$ens]->{SV}[$bin][$BEAM2] = &$Svfunc($LADCP{ENSEMBLE}[$ens]->{CTD_TEMP},
							 							    $LADCP{TRANSMITTED_PULSE_LENGTH},
														    $Er[$BEAM2],$range_to_bin,
							            			        $LADCP{ENSEMBLE}[$ens]->{ECHO_AMPLITUDE}[$bin][$BEAM2]);
			$LADCP{ENSEMBLE}[$ens]->{SV}[$bin][$BEAM3] = &$Svfunc($LADCP{ENSEMBLE}[$ens]->{CTD_TEMP},
							 							    $LADCP{TRANSMITTED_PULSE_LENGTH},
														    $Er[$BEAM3],$range_to_bin,
							            			        $LADCP{ENSEMBLE}[$ens]->{ECHO_AMPLITUDE}[$bin][$BEAM3]);
			$LADCP{ENSEMBLE}[$ens]->{SV}[$bin][$BEAM4] = &$Svfunc($LADCP{ENSEMBLE}[$ens]->{CTD_TEMP},
							 							    $LADCP{TRANSMITTED_PULSE_LENGTH},
														    $Er[$BEAM4],$range_to_bin,
							            			        $LADCP{ENSEMBLE}[$ens]->{ECHO_AMPLITUDE}[$bin][$BEAM4]);
			my($Sv) = avg(@{$LADCP{ENSEMBLE}[$ens]->{SV}[$bin]});

			$sSv[$gi][$bin] += $Sv;
			$nSv[$gi][$bin]++;

			if ($bin>=$Svbin_start && $bin<=$Svbin_end) {
				$sSv_prof[$gi] += $Sv;
				$nSv_prof[$gi]++;
			}
		}
	}
}

sub depthOfGI($) { return $_[0]*$GRID_DZ + $GRID_DZ/2; }		# depth corresponding to particular grid index

sub find_backscatter_seabed($)
{
	my($search_below) = @_;
	my($mdgi) = int($search_below/$GRID_DZ);					# grid index to begin search
	my(@wdepth_gi);												# water_depth indices

	print(STDERR "\n\tseabed-max grid indices:") if ($opt_d);
	
	for (my($bin)=0; $bin<$LADCP{N_BINS}; $bin++) { 			# find backscatter min/max below $search_below in each bin
		my($min,$max,$gimax,$lastvalid) = (1e99,-1e99,-1,-1);
		for (my($gi)=$mdgi; $gi<@nSv; $gi++) {
			next unless ($nSv[$gi][$bin] > 0);
			my($avg) = $sSv[$gi][$bin] / $nSv[$gi][$bin];
			$lastvalid = $gi;
			$min = $avg if ($avg < $min);
			$max = $avg, $gimax = $gi if ($avg > $max);
		}
		if ($max-$min>10 && $gimax!=$lastvalid) { 				# ignore boundary maxima & scatter
			printf(STDERR " %d",$gimax-$mdgi) if ($opt_d);
			push(@wdepth_gi,$gimax);
		}
	}
	
	return (depthOfGI(avg(@wdepth_gi)),stddev(@wdepth_gi)*$GRID_DZ);

}

1;
